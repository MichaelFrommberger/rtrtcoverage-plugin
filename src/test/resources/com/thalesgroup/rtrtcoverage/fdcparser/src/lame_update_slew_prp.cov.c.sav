/* Rational Test RealTime C Instrumentor 2002.05.21.468.004 */
/* Build Number: 282.001*/
/* Copyright(C) 2002 Rational Software Corporation. All rights reserved. */
/*   Date : 09-Oct-02 19:21 */
/*     OS : ms-dos */

#define ATL_C_INSTRUMENTOR

#define USE_ATC 1

#define ATC_INFORMATION 0

#include "D:\Viewsnap\IC_CDS_A400M\CDS_A400M_DEV\..\build_tools_cds_a400m_L3.1\DESK_CompilationChain/TDP/GNU\lib\TP.h"

#define _ATC_INIT_CONST_COMPOUND_STUFF

_ATC_DECLARE_PROC(1,8)
_ATC_DECLARE_CALL(1,5)
_ATC_DECLARE_BLOC(1,44)
_ATC_DECLARE(1,0x7584755UL,0x3E5A8DF9UL,8,_ATC_TAB_PROC(1),5,_ATC_TAB_CALL(1),44,_ATC_TAB_BLOC(1),0,0)

# 1 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/LA/Lame/Src/lame_update_slew_prp.c"












































# 1 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/LA/Lame/Src/lame_types.h"




























# 1 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/THEMIS/Interface/themis_basic_types.h"














 
 




 


typedef char T_CHAR; 
# 26 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/THEMIS/Interface/themis_basic_types.h"

 


typedef long T_BOOL; 
# 32 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/THEMIS/Interface/themis_basic_types.h"


# 35 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/THEMIS/Interface/themis_basic_types.h"








 


typedef float T_FLOAT; 
# 48 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/THEMIS/Interface/themis_basic_types.h"

 


typedef double T_FLOAT_L; 
# 54 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/THEMIS/Interface/themis_basic_types.h"

 


typedef long T_INT; 
# 60 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/THEMIS/Interface/themis_basic_types.h"

 


typedef short T_INT_S;
# 66 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/THEMIS/Interface/themis_basic_types.h"

 


typedef unsigned long T_UINT;
# 72 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/THEMIS/Interface/themis_basic_types.h"

 


typedef unsigned short T_UINT_S;
# 78 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/THEMIS/Interface/themis_basic_types.h"
  

 
 

 


typedef T_FLOAT T_POINT[2]; 
# 88 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/THEMIS/Interface/themis_basic_types.h"
  
 
 

 



typedef struct { 
  T_INT length; 
  T_CHAR data[32]; 
} T_STRING; 
# 101 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/THEMIS/Interface/themis_basic_types.h"











typedef struct
{
   char   	 port_name[32];
   T_UINT    port_mode;     
   T_UINT 	 refresh;
   T_UINT  	 size_max ;
   T_UINT    nb_msg; 		
} T_REF_MSG ;


 









# 133 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/THEMIS/Interface/themis_basic_types.h"
# 30 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/LA/Lame/Src/lame_types.h"
# 1 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/Common/INTERFACE/Cl/apsw_basic_types_c.h"
































typedef char				T_char;
# 35 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/Common/INTERFACE/Cl/apsw_basic_types_c.h"



typedef unsigned char		T_uchar;
# 40 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/Common/INTERFACE/Cl/apsw_basic_types_c.h"







typedef unsigned long		T_boolean;
# 49 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/Common/INTERFACE/Cl/apsw_basic_types_c.h"




typedef char				T_int8;
# 55 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/Common/INTERFACE/Cl/apsw_basic_types_c.h"


typedef short				T_int16;
# 59 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/Common/INTERFACE/Cl/apsw_basic_types_c.h"


typedef long				T_int32;
# 63 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/Common/INTERFACE/Cl/apsw_basic_types_c.h"




typedef unsigned char		T_uint8;
# 69 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/Common/INTERFACE/Cl/apsw_basic_types_c.h"



typedef unsigned short		T_uint16;
# 74 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/Common/INTERFACE/Cl/apsw_basic_types_c.h"



typedef unsigned long		T_uint32;
# 79 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/Common/INTERFACE/Cl/apsw_basic_types_c.h"





typedef unsigned long		T_ubfield;
# 86 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/Common/INTERFACE/Cl/apsw_basic_types_c.h"




typedef float				T_float32;
# 92 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/Common/INTERFACE/Cl/apsw_basic_types_c.h"



typedef double				T_float64;
# 97 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/Common/INTERFACE/Cl/apsw_basic_types_c.h"




typedef void				*T_ptr;
# 103 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/Common/INTERFACE/Cl/apsw_basic_types_c.h"



typedef unsigned long		T_addr;
# 108 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/Common/INTERFACE/Cl/apsw_basic_types_c.h"





# 114 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/Common/INTERFACE/Cl/apsw_basic_types_c.h"
# 31 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/LA/Lame/Src/lame_types.h"



















typedef enum
{
    K_LAME_CURSOR_REF_NO_CURSOR = 0,
    K_LAME_CURSOR_REF_SCREEN = 1,
    K_LAME_CURSOR_REF_AC = 2,
    K_LAME_CURSOR_REF_GND = 3,
    K_LAME_CURSOR_REF_BE = 4
} T_lame_cursor_reference;


typedef T_float32 T_lame_orientation;

typedef struct
{
    T_float32 x;
    T_float32 y;
} T_lame_cartesian_coordinate;

typedef struct
{
    T_lame_orientation bearing_wrt_north;
    T_lame_orientation bearing_wrt_heading;
    T_float32 range;
    T_float32 real_range;
} T_lame_relative_coordinate;

typedef struct
{
    T_float32 latitude;
    T_float32 longitude;
} T_lame_geographic_coordinate;

typedef struct
{
    T_lame_cartesian_coordinate screen;
    T_lame_geographic_coordinate geo;
} T_lame_position;

typedef enum
{
    K_LAME_CURSOR_LOOK_NORMAL,
    K_LAME_CURSOR_LOOK_BORDER
} T_lame_cursor_look;

typedef struct
{
    
    T_boolean displayed;
    
    T_boolean displayed_prev;
    
    
    T_lame_cursor_reference reference;
    
    T_lame_cursor_reference reference_prev;

    T_boolean border_look_forced;
    T_lame_cursor_look look;

    
    T_boolean be_activated;

    
    T_int32 ccd_dx;
    T_int32 ccd_dy;

    
    T_boolean on_prp;

    
    T_boolean position_computable;

       
    T_boolean prev_position_computable;

    
    T_lame_cartesian_coordinate screen_position;
    T_boolean screen_position_validity;
    T_boolean screen_position_validity_prev;
    
    T_lame_cartesian_coordinate screen_correction;  
    
    T_lame_cartesian_coordinate screen_required_correction;  
    
    T_lame_cartesian_coordinate absolute_position;
    
    T_lame_relative_coordinate relative_AC_position;
    
    T_lame_relative_coordinate relative_BE_position;
    
    T_lame_geographic_coordinate geographic_position;

    
    T_uint16 media_x;
    T_uint16 media_y;

    
    T_uint16 cursor_abs_x;
    T_uint16 cursor_abs_y;

    
    T_boolean trackball_moved;

    

    T_boolean force_centering;
    
    T_boolean immobilize;
} T_lame_cursor_configuration;

typedef struct
{
    
    T_boolean DU1_display_ntdi;
    
    T_lame_cursor_reference DU1_ntdi_reference;
    
    T_boolean DU2_display_ntdi;
    
    T_lame_cursor_reference DU2_ntdi_reference;
} T_lame_ntdi_foreign_cursor_reference;

typedef struct
{
    
    T_lame_cursor_reference ntd1_reference;
    
    T_lame_cursor_reference ntd2_reference;

    
    T_boolean initialized;

    
    T_boolean DU1_validity;
    T_boolean DU2_validity;

    
    T_lame_ntdi_foreign_cursor_reference ntd1_foreign_ref;
    T_lame_ntdi_foreign_cursor_reference ntd2_foreign_ref;
} T_lame_memorized_cursor_reference;




typedef enum
{
    K_LAME_FORMAT_NOT_NTD,
    K_LAME_FORMAT_NTD1,
    K_LAME_FORMAT_NTD2
} T_lame_format;

typedef enum
{
    K_LAME_NTD_MODE_NONE = 0,
    K_LAME_NTD_MODE_ROSE = 1,
    K_LAME_NTD_MODE_ARC = 2,
    K_LAME_NTD_MODE_VOR = 3,
    K_LAME_NTD_MODE_VD = 4,
    K_LAME_NTD_MODE_SLEW = 5,
    K_LAME_NTD_MODE_SLEW_FRZ = 6,
    K_LAME_NTD_MODE_PLAN = 7,
    K_LAME_NTD_MODE_PLAN_FRZ = 8,
    K_LAME_NTD_MODE_EXPAND = 9,
    K_LAME_NTD_MODE_EXPAND_FRZ = 10,
    K_LAME_NTD_MODE_SLAVE = 11,
    K_LAME_NTD_MODE_ROSE_FRZ = 12,
    K_LAME_NTD_MODE_ARC_FRZ  = 13,
    K_LAME_NTD_MODE_VOR_FRZ  = 14,
    K_LAME_NTD_MODE_VD_FRZ   = 15
} T_lame_ntd_mode;


typedef enum
{
    K_LAME_6x6_MODE,
    K_LAME_6x8_MODE
} T_lame_size;

typedef struct
{
    
    T_lame_format format;
    
    T_lame_format format_prev;

    
    T_lame_ntd_mode ntd_mode;
    
    T_lame_ntd_mode ntd_mode_prev;

    
    T_uint8 reconf_started_tempo;
    
    T_uint8 ntd_mode_changed_tempo;
    
    T_uint8 ntd_mode_changed_to_slew_tempo;
    
    T_uint8 cursor_animation_tempo;

    
    T_boolean popup_opened;
    
    T_boolean dialog_box_displayed;

    
    T_boolean range_valid;
    
    T_float32 range_factor_x;
    T_float32 range_factor_y;

    
    T_lame_orientation orientation;

    
    T_uint16 screen_x_min;
    T_uint16 screen_x_max;
    T_uint16 screen_y_min;
    T_uint16 screen_y_max;

    
    T_lame_size screen_size;

    
    T_uint16 padding;
    T_uint16 lower_padding;

} T_lame_display_configuration;





typedef enum
{
    K_LAME_FOREIGN_DU1 = 0,
    K_LAME_FOREIGN_DU2,
    K_LAME_NB_FOREIGN_DU
} T_lame_foreign_du_index;

typedef struct
{
    T_boolean validity;
    T_boolean display_ntd;
    T_lame_geographic_coordinate position;
} T_lame_foreign_slew_prp;

typedef struct
{
    
    T_lame_geographic_coordinate position;
    
    T_lame_geographic_coordinate last_position_on_side;
    
    T_lame_format format;
    
    T_boolean initialized;
    
    T_lame_foreign_slew_prp foreign_slew_prp [K_LAME_NB_FOREIGN_DU];
} T_lame_NTDi_slew_prp;

typedef struct
{
    T_lame_NTDi_slew_prp ntd1_slew_prp;
    T_lame_NTDi_slew_prp ntd2_slew_prp;
    T_boolean prp_reset;
    T_boolean prp_reset_prev;
} T_lame_slew_prp_configuration;




typedef struct
{
    T_boolean condition;
    T_lame_geographic_coordinate prp;
    T_float32 *range;
} T_lame_range_gap;



typedef enum
{
    K_LAME_VD_CIVIL = 1,
    K_LAME_VD_TACT = 2
} T_lame_vd_type;

typedef struct
{
    T_uint8 nb_range_gaps;
    T_lame_range_gap range_gaps [4];
} T_lame_ntd_range_gaps;

# 343 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/LA/Lame/Src/lame_types.h"

# 46 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/LA/Lame/Src/lame_update_slew_prp.c"
# 1 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/LA/Lame/Src/lame_conv_screen_to_en.p"





























































extern void lame_conv_screen_to_en (
                T_lame_cartesian_coordinate *par_ptr_point_screen_position,
                T_float32 par_f_orientation,
                T_float32 par_f_pixel_to_NM_x_factor,
                T_float32 par_f_pixel_to_NM_y_factor,
                T_lame_cartesian_coordinate *par_ptr_ref_screen_position,
                T_lame_cartesian_coordinate *par_ptr_point_en_position);
# 47 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/LA/Lame/Src/lame_update_slew_prp.c"
# 1 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/LA/Lame/Src/lame_conv_en_to_geo.p"




















































extern void lame_conv_en_to_geo (T_lame_cartesian_coordinate *par_ptr_east_north,
                          T_lame_geographic_coordinate *par_ptr_reference,
                          T_lame_geographic_coordinate *par_ptr_geo);
# 48 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/LA/Lame/Src/lame_update_slew_prp.c"
# 1 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/LA/Lame/Src/lame_update_slew_prp.p"

























































extern void lame_update_slew_prp (
    T_lame_NTDi_slew_prp         *par_ptr_slew_conf,
    T_lame_cursor_configuration  *par_ptr_cursor_config,
    T_lame_display_configuration *par_ptr_display_config,
    T_lame_geographic_coordinate *par_ptr_AC_position,
    T_lame_geographic_coordinate *par_ptr_current_PRP_position,
    T_boolean                     par_b_prp_reset);
# 49 "D:/Viewsnap/IC_CDS_A400M/CDS_A400M_DEV/LA/Lame/Src/lame_update_slew_prp.c"





static void lame_update_slew_prp_in_slew (
    T_lame_NTDi_slew_prp         *par_ptr_slew_conf,
    T_lame_cursor_configuration  *par_ptr_cursor_config,
    T_lame_display_configuration *par_ptr_display_config,
    T_lame_geographic_coordinate *par_ptr_current_PRP_position);

static void initialize_slew_prp (
    T_lame_NTDi_slew_prp         *par_ptr_slew_conf,
    T_lame_display_configuration *par_ptr_display_config,
    T_lame_geographic_coordinate *par_ptr_AC_position);

static void update_last_position_on_side (
    T_lame_NTDi_slew_prp         *par_ptr_slew_conf,
    T_lame_display_configuration *par_ptr_display_config);






























void lame_update_slew_prp (
    T_lame_NTDi_slew_prp         *par_ptr_slew_conf,
    T_lame_cursor_configuration  *par_ptr_cursor_config,
    T_lame_display_configuration *par_ptr_display_config,
    T_lame_geographic_coordinate *par_ptr_AC_position,
    T_lame_geographic_coordinate *par_ptr_current_PRP_position,
    T_boolean                     par_b_prp_reset)
{_ATC_LINK(1);{_ATC_PROC(1,1);{_ATC_BLOC(1,12);{
    if (par_ptr_slew_conf->initialized == 0UL)
    {_ATC_BLOC(1,0);{
        

        (_ATC_CALL(1,0),initialize_slew_prp (par_ptr_slew_conf,
                             par_ptr_display_config,
                             par_ptr_AC_position));
        par_ptr_slew_conf->initialized = 1UL;
    }}
    else
    {_ATC_BLOC(1,11);{
        (_ATC_CALL(1,1),update_last_position_on_side (par_ptr_slew_conf,
                                      par_ptr_display_config));
        


        if (par_ptr_display_config->format == par_ptr_slew_conf->format)
        {_ATC_BLOC(1,9);{
            if (par_b_prp_reset == 1UL)
            {_ATC_BLOC(1,1);{
                

                par_ptr_slew_conf->position.latitude  = 
                    par_ptr_current_PRP_position->latitude;
                par_ptr_slew_conf->position.longitude = 
                    par_ptr_current_PRP_position->longitude;
            }}
            else {_ATC_BLOC(1,8);if (par_ptr_display_config->ntd_mode == K_LAME_NTD_MODE_SLEW)
            {_ATC_BLOC(1,2);{
                (_ATC_CALL(1,2),lame_update_slew_prp_in_slew (par_ptr_slew_conf,
                                              par_ptr_cursor_config,
                                              par_ptr_display_config,
                                              par_ptr_current_PRP_position));
            }}
            else {_ATC_BLOC(1,7);if (par_ptr_display_config->ntd_mode == K_LAME_NTD_MODE_SLEW_FRZ)
            {_ATC_BLOC(1,5);{
                
                if (par_ptr_display_config->format_prev 
                    != par_ptr_display_config->format)
                {_ATC_BLOC(1,3);{
                    



                    par_ptr_slew_conf->position.latitude  = 
                        par_ptr_slew_conf->last_position_on_side.latitude;
                    par_ptr_slew_conf->position.longitude = 
                        par_ptr_slew_conf->last_position_on_side.longitude;
                }}
                else
                {_ATC_BLOC(1,4);{
                    
                    
                    
                    
                }}
            }}
            else
            {_ATC_BLOC(1,6);{
               
            }}}}
        }}
        else
        {_ATC_BLOC(1,10);{
            
            
        }}
    }}
    {_ATC_PROC(1,0);return;}
}}}}
























static void lame_update_slew_prp_in_slew (
    T_lame_NTDi_slew_prp         *par_ptr_slew_conf,
    T_lame_cursor_configuration  *par_ptr_cursor_config,
    T_lame_display_configuration *par_ptr_display_config,
    T_lame_geographic_coordinate *par_ptr_current_PRP_position)
{_ATC_LINK(1);{_ATC_PROC(1,3);{_ATC_BLOC(1,25);{
    T_lame_cartesian_coordinate loc_east_north_move;
    T_lame_cartesian_coordinate loc_ccd_delta;
    T_lame_cartesian_coordinate loc_ref;

    
    if (par_ptr_display_config->format_prev 
        != par_ptr_display_config->format)
    {_ATC_BLOC(1,13);{
        



        par_ptr_slew_conf->position.latitude  = 
            par_ptr_slew_conf->last_position_on_side.latitude;
        par_ptr_slew_conf->position.longitude = 
            par_ptr_slew_conf->last_position_on_side.longitude;
    }}
    else {_ATC_BLOC(1,24);if ((par_ptr_display_config->ntd_mode_prev
              != K_LAME_NTD_MODE_SLEW)
             && (par_ptr_display_config->ntd_mode_prev
                 != K_LAME_NTD_MODE_SLEW_FRZ))
    {_ATC_BLOC(1,14);{
        


        par_ptr_slew_conf->position.latitude  = 
            par_ptr_current_PRP_position->latitude;
        par_ptr_slew_conf->position.longitude = 
            par_ptr_current_PRP_position->longitude;
    }}
    else {_ATC_BLOC(1,23);if (par_ptr_cursor_config->displayed == 0UL)
    {_ATC_BLOC(1,15);{
        
        
    }}
    else {_ATC_BLOC(1,22);if ((par_ptr_cursor_config->displayed_prev == 0UL)
             && (par_ptr_display_config->ntd_mode_prev
                 == K_LAME_NTD_MODE_SLEW))
    {_ATC_BLOC(1,16);{
        
        
    }}
    else {_ATC_BLOC(1,21);if (par_ptr_display_config->ntd_mode_prev
             == K_LAME_NTD_MODE_SLEW_FRZ)
    {_ATC_BLOC(1,17);{
        
        
    }}
    else
    {_ATC_BLOC(1,20);{
        

        if (

            (par_ptr_display_config->ntd_mode_changed_to_slew_tempo == 0)
            && ((par_ptr_cursor_config->on_prp == 1UL)
                || (par_ptr_cursor_config->immobilize == 1UL))
            && ((par_ptr_cursor_config->ccd_dx != 0)
                || (par_ptr_cursor_config->ccd_dy != 0))
            && (par_ptr_display_config->range_valid == 1UL))

        {_ATC_BLOC(1,18);{
            
            loc_ccd_delta.x = par_ptr_cursor_config->ccd_dx;
            loc_ccd_delta.y = par_ptr_cursor_config->ccd_dy;
            loc_ref.x = 0;
            loc_ref.y = 0;
            (_ATC_CALL(1,3),lame_conv_screen_to_en (&loc_ccd_delta,
                                    0.0,
                                    par_ptr_display_config->range_factor_x,
                                    par_ptr_display_config->range_factor_y,
                                    &loc_ref,
                                    &loc_east_north_move));
            
            (_ATC_CALL(1,4),lame_conv_en_to_geo (&loc_east_north_move,
                                 &(par_ptr_slew_conf->position),
                                 &(par_ptr_slew_conf->position)));
        }}
        else
        {_ATC_BLOC(1,19);{
            
            
        }}
    }}}}}}
    {_ATC_PROC(1,2);return;}
}}}}



















static void initialize_slew_prp (
    T_lame_NTDi_slew_prp         *par_ptr_slew_conf,
    T_lame_display_configuration *par_ptr_display_config,
    T_lame_geographic_coordinate *par_ptr_AC_position)
{_ATC_LINK(1);{_ATC_PROC(1,5);{_ATC_BLOC(1,34);{
    T_lame_foreign_du_index loc_du_index;
    T_lame_foreign_slew_prp *loc_p_DUj_slew_prp;
    T_boolean loc_b_updated;

    




    

    par_ptr_slew_conf->last_position_on_side.latitude  = 
        par_ptr_AC_position->latitude;
    par_ptr_slew_conf->last_position_on_side.longitude = 
        par_ptr_AC_position->longitude;
    par_ptr_slew_conf->position.latitude  = 
        par_ptr_AC_position->latitude;
    par_ptr_slew_conf->position.longitude = 
        par_ptr_AC_position->longitude;
    
    loc_b_updated = 0UL;
    loc_du_index = 0;
    {_ATC_LOOP_bef(1,31);while ((loc_du_index < K_LAME_NB_FOREIGN_DU)
           && (loc_b_updated == 0UL))
    {_ATC_LOOP_in(1,31);{_ATC_BLOC(1,30);{
        loc_p_DUj_slew_prp = 
            &(par_ptr_slew_conf->foreign_slew_prp [loc_du_index]);
        if (loc_p_DUj_slew_prp->validity == 1UL)
        {_ATC_BLOC(1,28);{
            loc_b_updated = 1UL;

            
            par_ptr_slew_conf->last_position_on_side.latitude  = 
                loc_p_DUj_slew_prp->position.latitude;
            par_ptr_slew_conf->last_position_on_side.longitude = 
                loc_p_DUj_slew_prp->position.longitude;

            if ((par_ptr_display_config->format == par_ptr_slew_conf->format)
                && ((par_ptr_display_config->ntd_mode == K_LAME_NTD_MODE_SLEW)
                    || (par_ptr_display_config->ntd_mode == K_LAME_NTD_MODE_SLEW_FRZ)))
            {_ATC_BLOC(1,26);{
                
                par_ptr_slew_conf->position.latitude  = 
                    loc_p_DUj_slew_prp->position.latitude;
                par_ptr_slew_conf->position.longitude = 
                    loc_p_DUj_slew_prp->position.longitude;
            }}
            else
            {_ATC_BLOC(1,27);{
                
            }}
        }}
        else
        {_ATC_BLOC(1,29);{
            loc_du_index ++;
        }}
    }}}}
    
    {_ATC_PROC(1,4);return;}
}}}}




















static void update_last_position_on_side (
    T_lame_NTDi_slew_prp         *par_ptr_slew_conf,
    T_lame_display_configuration *par_ptr_display_config)
{_ATC_LINK(1);{_ATC_PROC(1,7);{_ATC_BLOC(1,43);{
    T_lame_foreign_du_index loc_du_index;
    T_lame_foreign_slew_prp *loc_p_DUj_slew_prp;
    T_boolean loc_b_updated;

    




    loc_du_index = 0;
    loc_b_updated = 0UL;
    {_ATC_LOOP_bef(1,38);while ((loc_du_index < K_LAME_NB_FOREIGN_DU)
           && (loc_b_updated == 0UL))
    {_ATC_LOOP_in(1,38);{_ATC_BLOC(1,37);{
        loc_p_DUj_slew_prp = 
            &(par_ptr_slew_conf->foreign_slew_prp [loc_du_index]);
        if ((loc_p_DUj_slew_prp->validity == 1UL) &&
            (loc_p_DUj_slew_prp->display_ntd == 1UL))
        {_ATC_BLOC(1,35);{
            
            par_ptr_slew_conf->last_position_on_side.latitude  = 
                loc_p_DUj_slew_prp->position.latitude;
            par_ptr_slew_conf->last_position_on_side.longitude = 
                loc_p_DUj_slew_prp->position.longitude;
            loc_b_updated = 1UL;
        }}
        else
        {_ATC_BLOC(1,36);{
            loc_du_index ++;
        }}
    }}}}
    if ((par_ptr_display_config->format == par_ptr_slew_conf->format)
        && (par_ptr_display_config->format_prev == par_ptr_slew_conf->format)
        && ((par_ptr_display_config->ntd_mode == K_LAME_NTD_MODE_SLEW)
            || (par_ptr_display_config->ntd_mode == K_LAME_NTD_MODE_SLEW_FRZ)))
    {_ATC_BLOC(1,41);{
        par_ptr_slew_conf->last_position_on_side.latitude  = 
            par_ptr_slew_conf->position.latitude;
        par_ptr_slew_conf->last_position_on_side.longitude = 
            par_ptr_slew_conf->position.longitude;
    }}
    else
    {_ATC_BLOC(1,42);{
        
    }}
        
    {_ATC_PROC(1,6);return;}
}}}}
